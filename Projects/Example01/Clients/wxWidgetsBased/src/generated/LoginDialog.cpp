// -*- C++ -*- generated by wxGlade 0.6.2 on Wed Jan 02 16:19:18 2008

#include "PacketBase.h"
#include "LoginDialog.h"
#include "Avatar.h"
#include <ace/Connector.h>
#include <ace/Svc_Handler.h>
#include <ace/SOCK_Connector.h>
#include <ace/SOCK_Stream.h>
#include <ace/Reactor_Notification_Strategy.h>
//#include "AuthPacket.h"

// begin wxGlade: ::extracode


// end wxGlade
class Auth_Handler : public ACE_Svc_Handler<ACE_SOCK_STREAM,ACE_NULL_SYNCH>
{
    typedef ACE_Svc_Handler<ACE_SOCK_STREAM, ACE_NULL_SYNCH> PARENT;
	AuthObserver *m_observer; 
public:
	Auth_Handler():notifier_ (0, this, ACE_Event_Handler::WRITE_MASK),m_observer(0)
	{
		ACE_ASSERT(!"Auth_Handler should not be automatically instantiated!");
	}
    Auth_Handler(AuthObserver *observer):notifier_ (0, this, ACE_Event_Handler::WRITE_MASK),m_observer(observer)
    {}
	
    virtual int open (void * = 0);

    // Called when input is available from the client.
    virtual int handle_input (ACE_HANDLE fd = ACE_INVALID_HANDLE);

    // Called when output is possible.
    virtual int handle_output (ACE_HANDLE fd = ACE_INVALID_HANDLE);

    // Called when a timer expires.
    virtual int handle_timeout (const ACE_Time_Value &current_time,
        const void *act = 0);

private:
    enum { ITERATIONS = 5 };
    int iterations_;
    ACE_Reactor_Notification_Strategy notifier_;
};

int Auth_Handler::open (void *p)
{
    ACE_Time_Value iter_delay (2);   // Two seconds
    if (PARENT::open (p) == -1)
        return -1;
    this->notifier_.reactor (this->reactor ());
    this->msg_queue ()->notification_strategy (&this->notifier_);
	int res= this->reactor ()->schedule_timer(this, 0, ACE_Time_Value::zero, iter_delay);
	if(res!=-1)
		m_observer->notify_connected();
	return res;
}
int Auth_Handler::handle_input (ACE_HANDLE)
{
    char buf[64];
    ssize_t recv_cnt = this->peer ().recv (buf, sizeof (buf) - 1);
    if (recv_cnt > 0)
    {
		m_observer->notify_raw_data(buf,recv_cnt);
        return 0;
    }
    if (recv_cnt == 0 || ACE_OS::last_error () != EWOULDBLOCK)
    {
        this->reactor ()->end_reactor_event_loop ();
		m_observer->notify_disconnected();
		return -1;
    }
    return 0;
}
int Auth_Handler::handle_timeout(const ACE_Time_Value &, const void *)
{
    if (this->iterations_ >= ITERATIONS)
    {
        this->peer ().close_writer ();
        return 0;
    }

    ACE_Message_Block *mb;
    char msg[128];
    ACE_OS::sprintf (msg, "Iteration %d\n", this->iterations_);
    ACE_NEW_RETURN (mb, ACE_Message_Block (msg), -1);
    this->putq (mb);
    return 0;
}
int Auth_Handler::handle_output (ACE_HANDLE)
{
    ACE_Message_Block *mb;
    ACE_Time_Value nowait (ACE_OS::gettimeofday ());
    while (-1 != this->getq (mb, &nowait))
    {
        ssize_t send_cnt = this->peer ().send (mb->rd_ptr (), mb->length ());
        if (send_cnt == -1)
            ACE_ERROR ((LM_ERROR,ACE_TEXT ("(%P|%t) %p\n"),ACE_TEXT ("send")));
        else
            mb->rd_ptr (ACE_static_cast (size_t, send_cnt));
        if (mb->length () > 0)
        {
            this->ungetq (mb);
            break;
        }
        mb->release ();
    }
    if (this->msg_queue ()->is_empty ())
        this->reactor ()->cancel_wakeup(this, ACE_Event_Handler::WRITE_MASK);
    else
        this->reactor ()->schedule_wakeup(this, ACE_Event_Handler::WRITE_MASK);
    return 0;
}



class Auth_Client_Connector : public ACE_Connector<Auth_Handler,ACE_SOCK_CONNECTOR>
{
    typedef ACE_Connector<Auth_Handler,ACE_SOCK_CONNECTOR> PARENT;
public:
    // Initialization
    Auth_Client_Connector (void){};
    ~Auth_Client_Connector (void){};
private:
    ACE_INET_Addr remote_addr_; // this is where the auth server lives
};

LoginDialog::LoginDialog(wxWindow* parent, int id, const wxString& title, const wxPoint& pos, const wxSize& size, long style):
    wxDialog(parent, id, title, pos, size, wxDEFAULT_DIALOG_STYLE)
{
    // begin wxGlade: LoginDialog::LoginDialog
    m_txt_login = new wxTextCtrl(this, wxID_ANY, wxEmptyString);
    m_txt_passw = new wxTextCtrl(this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_PASSWORD);
    m_server_response = new wxTextCtrl(this, wxID_ANY, wxEmptyString, wxDefaultPosition, wxSize(120,200), wxTE_MULTILINE);
    m_btn_login = new wxButton(this, wxID_ANY, wxT("Login"));
    m_btn_cancel = new wxButton(this, wxID_CANCEL, wxEmptyString);
    Auth_Client_Connector cntr;
    Auth_Handler *hndlr=new Auth_Handler(this);
    cntr.connect(hndlr,ACE_INET_Addr(2106,"127.0.0.1"));
    set_properties();
    do_layout();
    // end wxGlade
}


BEGIN_EVENT_TABLE(LoginDialog, wxDialog)
    // begin wxGlade: LoginDialog::event_table
    EVT_TEXT_ENTER(wxID_ANY, LoginDialog::OnSetLogin)
    EVT_TEXT_ENTER(wxID_ANY, LoginDialog::OnSetPassword)
	EVT_PAINT(LoginDialog::OnMyPaint)
    EVT_BUTTON(wxID_ANY, LoginDialog::OnLogin)
    // end wxGlade
END_EVENT_TABLE();


void LoginDialog::OnSetLogin(wxCommandEvent &event)
{
    event.Skip();
    wxLogDebug(wxT("Event handler (LoginDialog::OnSetLogin) not implemented yet")); //notify the user that he hasn't implemented the event handler yet
}


void LoginDialog::OnSetPassword(wxCommandEvent &event)
{
    event.Skip();
    wxLogDebug(wxT("Event handler (LoginDialog::OnSetPassword) not implemented yet")); //notify the user that he hasn't implemented the event handler yet
}


void LoginDialog::OnLogin(wxCommandEvent &event)
{
    event.Skip();
    wxLogDebug(wxT("Event handler (LoginDialog::OnLogin) not implemented yet")); //notify the user that he hasn't implemented the event handler yet
}


// wxGlade: add LoginDialog event handlers


void LoginDialog::set_properties()
{
    // begin wxGlade: LoginDialog::set_properties
    SetTitle(wxT("Testing logging in"));
    m_btn_login->SetDefault();
    // end wxGlade
}


void LoginDialog::do_layout()
{
    // begin wxGlade: LoginDialog::do_layout
    wxBoxSizer* sizer_1 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_3 = new wxBoxSizer(wxHORIZONTAL);
    wxBoxSizer* sizer_2 = new wxBoxSizer(wxHORIZONTAL);
    wxStaticText* label_1 = new wxStaticText(this, wxID_ANY, wxT("Login:"));
    sizer_2->Add(label_1, 0, wxALIGN_CENTER_VERTICAL, 0);
    sizer_2->Add(m_txt_login, 0, wxALIGN_CENTER_VERTICAL, 0);
    sizer_2->Add(20, 20, 1, 0, 0);
    wxStaticText* label_2 = new wxStaticText(this, wxID_ANY, wxT("Password:"));
    sizer_2->Add(label_2, 0, wxLEFT|wxALIGN_CENTER_VERTICAL, 11);
    sizer_2->Add(m_txt_passw, 0, wxALIGN_CENTER_VERTICAL, 0);
    sizer_1->Add(sizer_2, 0, wxLEFT|wxRIGHT|wxTOP|wxEXPAND, 3);
    sizer_1->Add(m_server_response, 1, wxALL|wxEXPAND, 3);
    sizer_3->Add(m_btn_login, 0, wxALIGN_CENTER_VERTICAL, 0);
    sizer_3->Add(20, 20, 1, 0, 0);
    sizer_3->Add(m_btn_cancel, 0, wxALIGN_CENTER_VERTICAL, 0);
    sizer_1->Add(sizer_3, 0, wxEXPAND, 0);
    SetSizer(sizer_1);
    sizer_1->Fit(this);
    Layout();
    // end wxGlade
}

void LoginDialog::OnMyPaint(wxPaintEvent &ev)
{
	wxDialog::OnPaint(ev);
	wxPaintDC m_dc(this);
	m_human1.draw_on(&m_dc,20,20);
}

void LoginDialog::notify_raw_data( char *dat,size_t sz )
{
	wxString raw_info = wxString::Format(wxT("Got raw data of size %d\n"),sz);
	(*m_server_response) << raw_info;
}
void LoginDialog::notify_connected()
{
	(*m_server_response) << wxT("CONNECTED\n");
}

void LoginDialog::notify_disconnected()
{
	(*m_server_response) << wxT("DISCONNECTED\n");
}
/*
	Component should be includeable into the project source as/is ( just writing 
		ADD_COMPONENT_MACRO(COMPONENT_NAME SOURCE) // adds component's sources to the target
		ADD_COMPONENT_MACRO(COMPONENT_NAME LIB) // adds component's include directory, and does ADD_DEPENDENCIES

	SEGS/
		CMakeScripts/
		Components/
			Server/
				ComponentName/
					include/
					src/
					Doc/
			Client/
				ComponentName/
					include/
					src/
					Doc/
			Common/
				ComponentName/
					include/
					src/
					Doc/

		Utilities/
		Projects/
			Example1/
				Servers/
				Clients/
				Utilities/
				Data/
				Doc/
				License.txt
				Readme.txt
				Authors.txt
			CoX/
				Servers/
				Clients/
				Utilities/
				Data/
				Doc/
				License.txt
				Readme.txt
				Authors.txt
			OtherWorldSpecificFilesHere/
				Servers/
				Clients/
				Utilities/
				Data/
				Doc/
				License.txt
				Readme.txt
				Authors.txt
		License.txt
		Readme.txt
		Authors.txt

*/